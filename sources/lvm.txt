
Logical volume manager
======================

Create an lvm partition bigger than two physical partitions
-----------------------------------------------------------

These commands can be copied and pasted with no ill effects. They will
not operate on your real hard drive partitions but on loop partitions.

#. create fake partition just for demonstration purpose with losetup::

     ~# sudo -s
     ~# dd if=/dev/zero of=hda1 bs=1M count=1G
     ~# dd if=/dev/zero of=hda2 bs=1M count=1G
     ~# losetup /dev/loop1 hda1        # for demonstration purpose, I create two fake 
     ~# losetup /dev/loop2 hda2        # partitions from newly created files with losetup.


#. At this point, there are two unused partitions. We can merge them
   into one::

     ~# pvcreate /dev/loop1
       Physical volume "/dev/loop1" successfully created
     
     ~# pvcreate /dev/loop2
       Physical volume "/dev/loop2" successfully created
     
     ~# vgcreate datadisks /dev/loop2 /dev/loop1
       Volume group "datadisks" successfully created
     
     ~# lvcreate -n muzak -L 1500M datadisks
       Logical volume "muzak" created

#. The partition ``/dev/mapper/datadisks-muzak`` is free, let's create a
   filesystem and put some file on it::
      
     ~# mkfs.ext4 /dev/mapper/datadisks-muzak
     ~# mkdir /mnt/muzak && mount /dev/mapper/datadisks-muzak /mnt/muzak
     ~# dd if=/dev/zero of=metronomy bs=1M count=1300
     ~# du -sh metronomy
       1300M     metronomy
     ~# cp metronomy /mnt/muzak

   From two partition of 1G, we created a *logical volume* of 1.5G in
   which we copied more data (1.3G) than available on each of the
   partitions taken separatly.

#. cleaning up::

     ~# umount /mnt/muzak

     ~# lvremove datadisks/muzak
     Do you really want to remove active logical volume "muzak"? [y/n]: y
       Logical volume "muzak" successfully removed
     
     ~# vgremove datadisks
       Volume group "datadisks" successfully removed
     
     ~# pvremove /dev/loop1 /dev/loop2
       Labels on physical volume "/dev/loop1" successfully wiped
       Labels on physical volume "/dev/loop2" successfully wiped
     
     ~# ### lvm cleanup is done by now, let's clean the fake partitions
     ~# losetup -d /dev/loop2
     ~# losetup -d /dev/loop1
     ~# rm hda{1,2} metronomy -r /mnt/muzek 


Safe upgrades through rollback
------------------------------

The example is a website with a database which gets into production
and needs to be updated 1. without service interruption, 2. safely.
Now, if the upgrade goes bad, we want a rollback and a short service
interruption is tolerated.

#. Create a fake physical partition, a lvm group and volume with a filesystem::

     ~# cd && sudo -s
     ~# dd if=/dev/zero of=hda1 bs=1M count=150
     ~# losetup /dev/loop1 hda1 
     ~# pvcreate /dev/loop1
       Physical volume "/dev/loop1" successfully created
     
     ~# vgcreate datadisks /dev/loop1
       Volume group "datadisks" successfully created

     ~# lvcreate -n website -L 100M datadisks
       Logical volume "website" created

     ~# mkfs.ext4 /dev/mapper/datadisks-website
     ~# mkdir /mnt/website && mount /dev/mapper/datadisks-website /mnt/website
     ~# touch /mnt/website/{database,index.html}

#. Put the system in production and make it public. Everyday, users
   are created in your database::

     ~# echo "name:alice,age:29" >> /mnt/website/database
     ~# echo "name:bob,age:18" >> /mnt/website/database

#. Now you want to upgrade the system, the database schema is modified
   to allow an id field. That's the database::

     ~# cat /mnt/website/database
     name:alice,age:29
     name:bob,age:18

   It should end up look like this::

     id=001,name:alice,age:29
     id=002,name:bob,age:18

   Architects and developper gather and we end up with an upgrade
   procedure composed of an lvm snapshot::

     ~# lvcreate -s -n website_backup -L 25M  /dev/datadisks/website

   of the working database and some database mangling commands::

     ~# nl -n rz -w 5 /mnt/website/database | sed 's/\t/,/; s/^/if:/' > /mnt/website/database.new
     ~# mv /mnt/website/database{.new,}

   The upgrade procedure require the database to go read only, no new
   users can be created. Comes the night of the upgrade, at dawn, the
   db looks like::

     ~# cat /mnt/website/database
     if=001,name:alice,age:29
     if=002;name:bob,age:18

   Ouuuch man! it is corrupted, there is no 'id' column in the
   database, plus it is written 'if' everywhere now and we have no
   clue why. We need to go back to the lab, figure out what
   happened... What do we do now? we need roll back so that the
   production site can continue, here is the command::

     ~# mkdir /mnt/backup
     ~# mount /dev/datadisks/website_backup /mnt/backup
     ~# cp /mnt/backup/database /mnt/website/database
     ~# umount /mnt/backup/database
     ~# lvremove /dev/datadisks/website_backup 
     ~# cat /mnt/website/database

#. Three weeks later many many more users have been created::

     ~# cat /mnt/website/database
     name:alice,age:29
     name:bob,age:18
     name:robwilco,age:35
     name:duncanmacleod,age:539

   and R&D has come up with a *complete* re-design of the upgrade
   procedure: a snapshot and some *correct* database mangling
   commands::

     ~# lvcreate -s -n website_backup -L 25M  /dev/datadisks/website
     ~# nl -n rz -w 5 /mnt/website/database | sed 's/\t/,/; s/^/id:/' > /mnt/website/database.new
     ~# mv /mnt/website/database{.new,}

   At dawn, the database is correct, the snapshot safety was
   thankfully not used::

     ~# cat /mnt/website/database
     id:00001,name:alice,age:29
     id:00002,name:bob,age:18
     id:00003,name:robwilco,age:35
     id:00004,name:duncanmacleod,age:539

   It is possible to remove the snapshot, and even after that the
   database is still up to date::

     ~# lvremove /dev/datadisks/website_backup 
     ~# cat /mnt/website/database
     id:00001,name:alice,age:29
     id:00002,name:bob,age:18
     id:00003,name:robwilco,age:35
     id:00004,name:duncanmacleod,age:539

#. To clean up after this exercice::

     ~# umount /mnt/website/
     ~# lvremove /dev/datadisks/website 
     ~# vgremove datadisks 
     ~# pvremove /dev/loop1
     ~# losetup -d /dev/loop1
     ~# rm hda1


Tips
----

Resetting the filesystem after an lvm hot resize resize
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may need the following so that lvs and df -h agrees on the disk sizes ::

  umount /dev/mapper/fnac-fnac
  e2fsck -f /dev/mapper/fnac-fnac
  resize2fs /dev/mapper/fnac-fnac
  
.. question 

Is the umount necessary ?

Mounting a logical volume from a livecd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You cannot boot a live CD and expect the logical volume to be "mount
ready" as is a standard ext4. You need to type ::

  vgscan --mknodes
  vgchange -ay

Now you're set ::

  lvscan
  mount /dev/mini/root /mnt/

Also, I could not ``vgscan``, with the feisty live even after having
installed ``lvm2`` (``Unable to mount drive ('LVM2_member')``, and
``No program “vgscan” found for your current version of LVM``). I had
to use the Knoppix liveCD v5, instead.

See also
--------

- http://www.debian-administration.org/articles/410
- http://www.linuxdevcenter.com/pub/a/linux/2006/04/27/managing-disk-space-with-lvm.html
- http://www.howtoforge.com/linux_lvm
- http://tldp.org/HOWTO/LVM-HOWTO/

